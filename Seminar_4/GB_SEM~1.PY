# -*- coding: utf-8 -*-
"""GB_seminar_30-05-2024

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13cqIan3oJiiOg7sEVcQKCiOlh-dcmMcp

### Данный код доступен всем по ссылке: https://colab.research.google.com/drive/13cqIan3oJiiOg7sEVcQKCiOlh-dcmMcp?usp=sharing

## Практическое задание к семинару № 4 от 30-05-2024

## Тема “Визуализация данных в Matplotlib”

### Задание 1
Загрузите модуль pyplot библиотеки matplotlib с псевдонимом plt, а также библиотеку numpy с псевдонимом np.
<p/>Примените магическую функцию %matplotlib inline для отображения графиков в Jupyter Notebook и настройки конфигурации ноутбука со значением 'svg' для более четкого отображения графиков.
<p/>Создайте список под названием x с числами 1, 2, 3, 4, 5, 6, 7 и список y с числами 3.5, 3.8, 4.2, 4.5, 5, 5.5, 7.
<p/>С помощью функции plot постройте график, соединяющий линиями точки с горизонтальными координатами из списка x и вертикальными - из списка y.
<p/>Затем в следующей ячейке постройте диаграмму рассеяния (другие названия - диаграмма разброса, scatter plot).
"""

# Commented out IPython magic to ensure Python compatibility.
# Импортируем необходимые библиотеки
import matplotlib.pyplot as plt
import numpy as np

# Настраиваем Jupyter Notebook для отображения графиков с более четким отображением
# %matplotlib inline
# %config InlineBackend.figure_format = 'svg'

# Создаем списки данных
x = [1, 2, 3, 4, 5, 6, 7]
y = [3.5, 3.8, 4.2, 4.5, 5, 5.5, 7]

# Построение линейного графика
plt.plot(x, y)
plt.xlabel('x')
plt.ylabel('y')
plt.title('Line Plot')
plt.show()

# Построение диаграммы рассеяния
plt.scatter(x, y)
plt.xlabel('x')
plt.ylabel('y')
plt.title('Scatter Plot')
plt.show()

"""### Задание 2
С помощью функции linspace из библиотеки Numpy создайте массив t из 51 числа от 0 до 10 включительно. Создайте массив Numpy под названием f, содержащий косинусы элементов массива t. Постройте линейную диаграмму, используя массив t для координат по горизонтали,а массив f - для
координат по вертикали. Линия графика должна быть зеленого цвета.
Выведите название диаграммы - 'График f(t)'. Также добавьте названия для горизонтальной оси - 'Значения t' и для вертикальной - 'Значения f'.
Ограничьте график по оси x значениями 0.5 и 9.5, а по оси y - значениями -2.5 и 2.5.
"""

# Создаем массив t из 51 числа от 0 до 10 включительно
t = np.linspace(0, 10, 51)

# Создаем массив f, содержащий косинусы элементов массива t
f = np.cos(t)

# Построение линейной диаграммы
plt.plot(t, f, color='green')
plt.title('График f(t)')
plt.xlabel('Значения t')
plt.ylabel('Значения f')

# Ограничиваем график по оси x значениями 0.5 и 9.5, а по оси y - значениями -2.5 и 2.5
plt.xlim(0.5, 9.5)
plt.ylim(-2.5, 2.5)

# Отображение графика
plt.show()

"""### *Задание 3
С помощью функции linspace библиотеки Numpy создайте массив x из 51 числа от -3 до 3 включительно. Создайте массивы y1, y2, y3, y4 по следующим формулам:
<p/>y1 = x**2
<p/>y2 = 2 * x + 0.5
<p/>y3 = -3 * x - 1.5
<p/>y4 = sin(x)
<p/>Используя функцию subplots модуля matplotlib.pyplot, создайте объект matplotlib.figure.Figure с названием fig и массив объектов Axes под названием ax,причем так, чтобы у вас было 4 отдельных
графика в сетке, состоящей из двух строк и двух столбцов. В каждом графике массив x используется для координат по горизонтали.В левом верхнем графике для координат по вертикали используйте y1,в правом верхнем - y2, в левом нижнем - y3, в правом нижнем - y4.Дайте название графикам: 'График y1', 'График y2' и т.д.
<p/>Для графика в левом верхнем углу установите границы по оси x от -5 до 5. Установите размеры фигуры 8 дюймов по горизонтали и 6 дюймов по вертикали. Вертикальные и горизонтальные зазоры между графиками должны составлять 0.3.
"""

# Создаем массив x из 51 числа от -3 до 3 включительно
x = np.linspace(-3, 3, 51)

# Создаем массивы y1, y2, y3, y4 по указанным формулам
y1 = x ** 2
y2 = 2 * x + 0.5
y3 = -3 * x - 1.5
y4 = np.sin(x)

# Используем функцию subplots для создания фигуры и массива объектов Axes
fig, ax = plt.subplots(2, 2, figsize=(8, 6))

# Левый верхний график
ax[0, 0].plot(x, y1)
ax[0, 0].set_title('График y1')
ax[0, 0].set_xlim(-5, 5)

# Правый верхний график
ax[0, 1].plot(x, y2)
ax[0, 1].set_title('График y2')

# Левый нижний график
ax[1, 0].plot(x, y3)
ax[1, 0].set_title('График y3')

# Правый нижний график
ax[1, 1].plot(x, y4)
ax[1, 1].set_title('График y4')

# Устанавливаем вертикальные и горизонтальные зазоры между графиками
plt.subplots_adjust(hspace=0.3, wspace=0.3)

# Отображение графиков
plt.show()

"""### *Задание 4
В этом задании мы будем работать с датасетом, в котором приведены данные по мошенничеству с кредитными данными: Credit Card Fraud Detection (информация об авторах: Andrea Dal Pozzolo, Olivier
Caelen, Reid A. Johnson and Gianluca Bontempi. Calibrating Probability with Undersampling for Unbalanced Classification. In Symposium on Computational Intelligence and Data Mining (CIDM), IEEE, 2015).
Ознакомьтесь с описанием и скачайте датасет creditcard.csv с сайта Kaggle.com по ссылке:
<p/> https://www.kaggle.com/datasets/mlg-ulb/creditcardfraud
<p/>Данный датасет является примером несбалансированных данных, так как мошеннические операции с картами встречаются реже обычных.
Импортируйте библиотеку Pandas, а также используйте для графиков стиль “fivethirtyeight”.
<p/>Посчитайте с помощью метода value_counts количество наблюдений для каждого значения целевой переменной Class и примените к полученным данным метод plot, чтобы построить столбчатую диаграмму. Затем постройте такую же диаграмму, используя логарифмический масштаб.
На следующем графике постройте две гистограммы по значениям признака V1 - одну для мошеннических транзакций (Class равен 1) и другую - для обычных (Class равен 0). Подберите значение аргумента density так, чтобы по вертикали графика было расположено не число наблюдений, а плотность распределения. Число бинов должно равняться 20 для обеих гистограмм, а коэффициент alpha сделайте равным 0.5, чтобы гистограммы были полупрозрачными и не загораживали друг друга. Создайте легенду с двумя значениями: “Class 0” и “Class 1”. Гистограмма
обычных транзакций должна быть серого цвета, а мошеннических - красного. Горизонтальной оси дайте название “V1”.
"""

# Импортируем необходимые библиотеки
import pandas as pd

# Устанавливаем стиль графиков
plt.style.use('fivethirtyeight')

# Загружаем датасет
df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/GB_Python_libraries_for_Data_Science/creditcard.csv')

# Посчитаем количество наблюдений для каждого значения целевой переменной Class
class_counts = df['Class'].value_counts()

# Построим столбчатую диаграмму
class_counts.plot(kind='bar')
plt.title('Столбчатая диаграмма')
plt.xlabel('Class')
plt.ylabel('Количество наблюдений')
plt.show()

# Построим логарифмическую столбчатую диаграмму
class_counts.plot(kind='bar', log=True)
plt.title('Столбчатая диаграмма (логарифмическая шкала)')
plt.xlabel('Class')
plt.ylabel('Количество наблюдений')
plt.show()

# Построим две гистограммы по значениям признака V1
plt.hist(df[df['Class'] == 0]['V1'], bins=20, density=True, alpha=0.5, color='grey', label='Class 0')
plt.hist(df[df['Class'] == 1]['V1'], bins=20, density=True, alpha=0.5, color='red', label='Class 1')

# Добавим легенду и подписи осей
plt.legend()
plt.xlabel('V1')
plt.ylabel('Плотность распределения')
plt.title('Распределение признака V1')
plt.show()

"""### **Задание на повторение материала

1. Создать одномерный массив Numpy под названием a из 12 последовательных целых чисел чисел от 12 до 24 невключительно
"""

import numpy as np

a = np.arange(12, 24)
print(a)

"""2. Создать 5 двумерных массивов разной формы из массива a. Не использовать в аргументах
метода reshape число -1.
"""

# Создание двумерных массивов разной формы
array_2x6 = a.reshape(2, 6)
array_3x4 = a.reshape(3, 4)
array_4x3 = a.reshape(4, 3)
array_6x2 = a.reshape(6, 2)
array_12x1 = a.reshape(12, 1)

# Вывод созданных массивов
print("2x6 array:\n", array_2x6)
print("\n3x4 array:\n", array_3x4)
print("\n4x3 array:\n", array_4x3)
print("\n6x2 array:\n", array_6x2)
print("\n12x1 array:\n", array_12x1)

"""3. Создать 5 двумерных массивов разной формы из массива a. Использовать в аргументах метода reshape число -1 (в трех примерах - для обозначения числа столбцов, в двух - для строк)."""

# Создаем 5 двумерных массивов разной формы

# Пример 1: 3 строки, количество столбцов вычисляется автоматически
array1 = a.reshape(3, -1)

# Пример 2: 4 строки, количество столбцов вычисляется автоматически
array2 = a.reshape(4, -1)

# Пример 3: 2 строки, количество столбцов вычисляется автоматически
array3 = a.reshape(2, -1)

# Пример 4: количество строк вычисляется автоматически, 3 столбца
array4 = a.reshape(-1, 3)

# Пример 5: количество строк вычисляется автоматически, 4 столбца
array5 = a.reshape(-1, 4)

# Выводим полученные массивы
print("Array 1:")
print(array1)
print("\nArray 2:")
print(array2)
print("\nArray 3:")
print(array3)
print("\nArray 4:")
print(array4)
print("\nArray 5:")
print(array5)

"""4. Можно ли массив Numpy, состоящий из одного столбца и 12 строк,назвать одномерным?"""

### Массив Numpy, состоящий из одного столбца и 12 строк, нельзя назвать одномерным.
### Такой массив является двумерным, поскольку у него есть две оси: строки и столбцы.
### Даже с точки зрения интерпретатора Python такой масив не является одномерным. Выведем количество измерений такого массива:

# Определим количество измерений на уже созданном ранее массиве из одного столбца и 12 строк.
dimensions = array_12x1.ndim

print("Массив:")
print(array_12x1)
print("\nКоличество измерений:", dimensions)

"""5. Создать массив из 3 строк и 4 столбцов, состоящий из случайных чисел с плавающей запятой из нормального распределения со средним, равным 0 и среднеквадратичным отклонением, равным 1.0. Получить из этого массива одномерный массив с таким же атрибутом size, как и исходный массив."""

# Создаем массив 3x4, состоящий из случайных чисел с плавающей запятой из нормального распределения
array_3x4 = np.random.normal(0, 1, (3, 4))

# Получаем одномерный массив с таким же атрибутом size
array_1d = array_3x4.flatten()

print("Массив 3x4:")
print(array_3x4)
print("\nОдномерный массив с таким же атрибутом size:")
print(array_1d)
print("\nРазмер одномерного массива:", array_1d.size)

"""6. Создать массив a, состоящий из целых чисел, убывающих от 20 до 0 невключительно с интервалом 2."""

# Создаем массив целых чисел, убывающих от 20 до 0 невключительно с интервалом 2
a = np.arange(20, 0, -2)

print("Массив a:")
print(a)

"""7. Создать массив b, состоящий из 1 строки и 10 столбцов: целых чисел, убывающих от 20 до 1 невключительно с интервалом 2. В чем разница между массивами a и b?"""

# Создаем массив b
b = np.arange(20, 1, -2).reshape(1, -1)

print("Массив b:")
print(b)

# Разница между массивами a и b
print("\nРазница между массивами a и b:")
print(f"Форма массива a: {a.shape}")
print(f"Форма массива b: {b.shape}")

"""8. Вертикально соединить массивы a и b. a - двумерный массив из нулей, число строк которого больше 1 и на 1 меньше, чем число строк двумерного массива b, состоящего из единиц. Итоговый массив v должен иметь атрибут size, равный 10."""

# Создаем массив a из нулей
a = np.zeros((2, 2))

# Создаем массив b из единиц
b = np.ones((3, 2))

# Соединяем массивы a и b
v = np.vstack((a, b))

print("\nИтоговый массив v:")
print(v)
print(f"Размер массива v: {v.size}")

"""9. Создать одномерный массив а, состоящий из последовательности целых чисел от 0 до 12. Поменять форму этого массива, чтобы получилась матрица A (двумерный массив Numpy), состоящая из 4 строк и 3 столбцов. Получить матрицу At путем транспонирования матрицы A.
Получить матрицу B, умножив матрицу A на матрицу At с помощью матричного умножения. Какой размер имеет матрица B? Получится ли вычислить обратную матрицу для матрицы B и
почему?
"""

# Создаем одномерный массив а
a = np.arange(0, 12)

# Меняем форму массива
A = a.reshape(4, 3)
At = A.T

# Умножаем матрицы A и At
B = np.dot(A, At)

print("\nМатрица A:")
print(A)
print("\nМатрица At:")
print(At)
print("\nМатрица B:")
print(B)
print(f"Размер матрицы B: {B.shape}")

# Проверяем возможность вычисления обратной матрицы
try:
    B_inv = np.linalg.inv(B)
    print("\nОбратная матрица B:")
    print(B_inv)
except np.linalg.LinAlgError:
    print("\nОбратная матрица для матрицы B не существует, так как матрица вырождена.")

"""10. Инициализируйте генератор случайных числе с помощью объекта seed, равного 42."""

np.random.seed(42)

"""11. Создайте одномерный массив c, составленный из последовательности 16-ти случайных равномерно распределенных целых чисел от 0 до 16 невключительно."""

# Создаем массив c
c = np.random.randint(0, 16, 16)

print("\nМассив c:")
print(c)

"""12. Поменяйте его форму так, чтобы получилась квадратная матрица C. Получите матрицу D, поэлементно прибавив матрицу B из предыдущего вопроса к матрице C, умноженной на 10. Вычислите определитель, ранг и обратную матрицу D_inv для D."""

# Меняем форму массива c
C = c.reshape(4, 4)

# Получаем матрицу D
D = B + C * 10

print("\nМатрица C:")
print(C)
print("\nМатрица D:")
print(D)

# Вычисляем определитель, ранг и обратную матрицу D_inv
det_D = np.linalg.det(D)
rank_D = np.linalg.matrix_rank(D)
D_inv = np.linalg.inv(D)

print("\nОпределитель матрицы D:")
print(det_D)
print("\nРанг матрицы D:")
print(rank_D)
print("\nОбратная матрица D_inv:")
print(D_inv)

"""13. Приравняйте к нулю отрицательные числа в матрице D_inv, а положительные - к единице. Убедитесь, что в матрице D_inv остались только нули и единицы. С помощью функции numpy.where, используя матрицу D_inv в качестве маски, а матрицы B и C - в качестве источников данных, получите матрицу E размером 4x4. Элементы матрицы E, для которых
соответствующий элемент матрицы D_inv равен 1, должны быть равны соответствующему элементу матрицы B, а элементы матрицы E, для которых соответствующий элемент матрицы D_inv равен 0, должны быть равны соответствующему элементу матрицы C.
"""

# Преобразуем элементы матрицы D_inv
D_inv[D_inv < 0] = 0
D_inv[D_inv > 0] = 1

print("\nМатрица D_inv с нулями и единицами:")
print(D_inv)

# Создаем матрицу E
E = np.where(D_inv == 1, B, C)

print("\nМатрица E:")
print(E)
